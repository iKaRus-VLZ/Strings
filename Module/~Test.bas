Attribute VB_Name = "~Test"
Option Compare Database
'=========================
Private Const c_strModule As String = "~App"
'=========================
' Описание      : для экспериментов
' Версия        : 1.0.0.0
' Дата          : 01.07.2016 15:00:00
' Автор         : Кашкин Р.В. (KashRus@gmail.com)
' Примечание    :
'=========================
Public Function GroupsGet2(Source As String, _
    ByRef cGroups As Collection, _
    Optional UsePlaceHolders As Boolean = False, _
    Optional Templates, Optional TermDelim = "@", Optional TempDelim = ";", _
    Optional aGroupPos) As Boolean
' возвращает коллекцию групп содержащихся в строке (выражений заключенных в скобки)
'-------------------------
' Source    - выражение содержащее скобки
' cGroups   - (возвращаемое) коллекция содержимого скобок индекс элемента соответствует уровню скобки в порядке разбора
'             именованные индексы соответствуют порядковому номеру с префиксом Br
'             коллекция нужна для возможности использования результата соместно с функциями PlaceHoldersGet/Set
' UsePlaceHolders - если True в Text, будут возвращены выражения содержащее подстановочные ссылки на соотв элементы массива результата
'             вида: ([%1%])+([%2%]), где 1,2.. - индексы элементов коллекции cGroups хранящей содержимое скобок
'             иначе - полное текстовое выражение содержащееся в скобках.
' Templates - строка или массив строк содержащий шаблоны допустимых групп
'             т.к. скобки проверяются прямым перебором составные скобки надо ставить вначале
' TermDelim  - разделитель элементов (замещающий символ для обозначения извлекаемого элемента группы) в строке шаблона
' TempDelim  - разделитель шаблонов в строке
' aGroupPos - (возвращаемое) массив позиций элементов строки (уровней групп/границ групп/содержимого групп)
' возвращает: True  - если выражение успешно разобрано,
'             False - если выражение содержит незакрытые скобки или не корректно
'-------------------------
' v.1.0.2       : 12.03.2024 - первая попытка переделать скобки под шаблоны
' v.1.0.1       : 21.12.2022 - исправлены многочисленные ошибки. (всё еще сильно экспериментальная)
' v.1.0.0       : 24.03.2020 - исходная (очень кривая и глючная) версия
'-------------------------
' ToDo: алгоритм срабатывает на первый сработавший шаблон, но элементы могут встречаться в разных шаблонах, сейчас и правильным может оказаться не первый - надо предусмотреть
'       распознавание повторяющихся и необязательных элементов в шаблонах например (@[,@]) м.б. (@);(@,@),(@,@,@) и т.д.
'-------------------------
' Примеры:
' 1) strText = "Do: If True Then 1 Else 0 End If: Loop"
'    strTemp = "If @ Then @ Else @ End If;Do: @: Loop"
'    Call GroupsGet(strText, cGroup, True, strTemp)
' 2) strText = "((5+2)+3*(4+5)^4)-97"
'    Call GroupsGet(strText, cGroup, True)
'-------------------------
#Const TestErr = False  ' проверять ошибку несогласованных скобок
Const cPref = "Br"      ' префикс именованного элемента коллекции
Const errUnclosedExp = vbObjectError + 511
Const errIncompleteExp = vbObjectError + 512
Dim Result As Boolean ': Result = False
On Error GoTo HandleError
    If Len(Source) = 0 Then Result = True: GoTo HandleExit
' задаем допустимые шаблоны групп (скобок)
Dim sTerm, sName As String
Dim aTemp               ' массив массивов элементов шаблона
Dim t As Long           ' индекс шаблона в массиве
    If IsMissing(Templates) Then
' не задано - берём набор скобок по-умолчанию
        aTemp = Array(Array("(", ")"), Array("[", "]"), Array("{", "}"), _
                      Array("<", ">"), Array("%", "%"), _
                      Array("'", "'"), Array("""", """"))
    ElseIf IsArray(Templates) Then
' задано одномерным массивом (не проверяется)
        ReDim aTemp(LBound(aTemp), UBound(aTemp)): For t = LBound(aTemp) To UBound(aTemp): aTemp(t) = Split(Templates(t), TermDelim): Next t
    Else
' задано строкой
        ReDim aTemp(0 To 0): For Each sTerm In Split(Templates, TempDelim): ReDim Preserve aTemp(0 To t): aTemp(t) = Split(sTerm, TermDelim): t = t + 1: Next sTerm
    End If
Dim l As Long           ' индекс проверяемого элемента шаблона = LBound(aTemp(t)) - открывающая скобка, =UBound(aTemp(t)) - закрывающая скобка, остальное - промежуточные скобки
Dim i As Long           ' позиция символа в разбираемой строке
Dim j As Long           ' индекс стека
Dim g As Long           ' индекс элемента массива для хранения результата разбора
Dim aStack() As Long    ' имитируем стек скобок
Const sStep = 3         ' шаг элементов массива стека
                ' +0    '(.TempNum) номер шаблона по массиву
                ' +1    '(.TempItm) номер элемента шаблона
                ' +2    '(.TempBeg) позиция начала подстроки в исходной строке (включая скобки)
'Dim aGroupPos() As Long ' массив для хранения результата разбора
Const gStep = 7         ' шаг элементов массива позиций элементов
                ' +0    '(.TextLev) уровень вложенности (0-вне скобок, 1-внешние скобки, ... n-скобки n-уровня)
                ' +1    '(.TextBeg) позиция начала текста подстроки в исходной строке (после открывающей скобки)
                ' +2    '(.TextEnd) позиция конца текста подстроки в исходной строке (до закрывающей скобки)
                ' +3    '(.TempBeg) позиция начала подстроки в исходной строке (включая скобки)
                ' +4    '(.TempEnd) позиция конца подстроки в исходной строке (включая скобки)
                ' +5    '(.TempNum) номер шаблона по массиву
                ' +6    '(.TempItm) номер элемента в шаблоне
Dim iBeg As Long, iEnd As Long, iLen As Long
    ReDim aGroupPos(1 To 1) As Long
    Set cGroups = New Collection
' ищем парные скобки в строке используя стек
    i = 1
    Do Until i > Len(Source)
' проверяем символы в текущей позиции
        iLen = 1        ' просматриваем строку посимвольно
        If j > 0 Then
    ' если в стеке есть незакрытые скобки
            ' проверяем следующий элемент для шаблона с вершины стека
            t = aStack(j - 2)                       '(.TempNum) номер шаблона по массиву
            l = aStack(j - 1)                       '(.TempItm) номер элемента шаблона
            sTerm = aTemp(t)(l + 1)
            If sTerm = Mid$(Source, i, Len(sTerm)) Then
            ' если совпадает - извлекаем фрагмент строки в результат
            ' заносим фрагмент в результат
                g = g + gStep: ReDim Preserve aGroupPos(1 To g) 'As Long
                iLen = Len(aTemp(t)(l))             ' длина подстроки предыдущего элемента шаблона
                iBeg = aStack(j - 0)                ' позиция начала подстроки предыдущего элемента шаблона в исходной строке
                iEnd = iBeg + iLen                  ' позиция конца подстроки предыдущего элемента шаблона в исходной строке
                iLen = Len(sTerm)                   ' длина подстроки текущего элемента шаблона
                l = l + 1                           ' переходим к следующему элементу текщего шаблона
                
                aGroupPos(g - 6) = j \ sStep        '(.TextLev) уровень вложенности (0-вне скобок, 1-внешние скобки, ... n-скобки n-уровня)
                aGroupPos(g - 5) = iEnd             '(.TextBeg) позиция начала текста подстроки в исходной строке (после открывающей скобки)
                aGroupPos(g - 4) = i                '(.TextEnd) позиция конца текста подстроки в исходной строке (до закрывающей скобки)
                aGroupPos(g - 3) = iBeg             '(.TempBeg) позиция начала подстроки в исходной строке (включая скобки)
                aGroupPos(g - 2) = i + iLen         '(.TempEnd) позиция конца подстроки в исходной строке (включая скобки)
                aGroupPos(g - 1) = t                '(.TempNum) номер шаблона по массиву
                aGroupPos(g - 0) = l                '(.TempItm) номер элемента в шаблоне
            ' заносим содержимое скобки в результирующую коллекцию
                sTerm = Mid$(Source, iEnd, i - iEnd)                    ' очищенный от внешних скобок фрагмент
                sName = cPref & (g \ gStep): cGroups.Add sTerm, sName   ' добавляем в коллекцию
                If l = UBound(aTemp(t)) Then
            ' если текущий элемент закрывающий - уменьшаем вершину стека
                    j = j - sStep: If j > 0 Then ReDim Preserve aStack(1 To j) Else Erase aStack   ' уменьшаем стек
                Else
            ' иначе увеличиваем в стеке уровень элемента шаблона и его позицию
                    aStack(j - 1) = l               '(.TempLev) номер элемента шаблона
                    aStack(j - 0) = i               '(.TempBeg) позиция начала подстроки в исходной строке (включая скобки)
                End If
                GoTo HandleNextSym                  ' фрагмент найден и разобран - переход к следующему символу
            End If
        End If
' проверяем первый (открывающий) элемент всех шаблонов
        For t = LBound(aTemp) To UBound(aTemp)
            l = LBound(aTemp(t)): sTerm = aTemp(t)(l)
            If sTerm = Mid(Source, i, Len(sTerm)) Then
            ' если открывающий элемент совпадает с текущим фрагментом строки
                If l < UBound(aTemp(t)) Then
                ' если текущий элемент не закрывающий (простые разделители сразу и открывающие и закрывающие) - заносим его в стек
                    j = j + sStep: ReDim Preserve aStack(1 To j) ' увеличиваем стек
                    aStack(j - 2) = t               '(.TempNum) номер шаблона по массиву
                    aStack(j - 1) = l               '(.TempItm) номер элемента шаблона
                    aStack(j - 0) = i               '(.TempBeg) позиция начала подстроки в исходной строке (включая скобки)
                End If
                iLen = Len(sTerm)                   ' смещаем позицию в строке на длину найденного фрагмента
                GoTo HandleNextSym ': Exit For      ' фрагмент найден и разобран - переход к следующему символу
            End If
        Next t
#If TestErr Then
' можно дополнительно выполнить проверку незакрытых скобок - проверить соответствие все м остальным скобкам не являющимся открывающими и вернуть позицию ошибки
        For t = LBound(aTemp) To UBound(aTemp)
            For l = LBound(aTemp(t)) + 1 To UBound(aTemp(t))
            sTerm = aTemp(t)(l): If sTerm = Mid$(Source, i, Len(sTerm)) Then sName = aTemp(t)(l - 1): Err.Raise errIncompleteExp
        Next l: Next t
#End If
' текущий фрагмент строки - содержимое скобки - просто переходим к следующему символу
HandleNextSym: i = i + iLen    ' смещаем указатель в строке на следующий после проанализированного символ
    Loop
'#If TestErr Then
'' проверяем наличие в стеке незакрытых скобок
    If j <> 0 Then sTerm = Join(aTemp(aStack(j - 2)), "..."): i = aStack(j): Err.Raise errUnclosedExp
'#End If
    Erase aStack
' если UsePlaceHolders=False необходимости добавлять внешнее выражение в результат нет,
' т.к. оно совпадает с Source, но для единообразия - сделаем.
    ' добавляем внешний уровень массива результата для исходной строки
' заносим фрагмент в результат
    g = g + gStep: ReDim Preserve aGroupPos(1 To g) 'As tTerm
    'aGroupPos(g - 6) = 0                '(.TextLev) уровень вложенности (0-вне скобок)
    aGroupPos(g - 5) = 1                '(.TextBeg) позиция начала текста подстроки в исходной строке (после открывающей скобки)
    aGroupPos(g - 4) = Len(Source) + 1  '(.TextEnd) позиция конца текста подстроки в исходной строке (до закрывающей скобки)
    aGroupPos(g - 3) = 1                '(.TempBeg) позиция начала подстроки в исходной строке (включая скобки)
    aGroupPos(g - 2) = Len(Source) + 1  '(.TempEnd) позиция конца подстроки в исходной строке (включая скобки)
    aGroupPos(g - 1) = -1               '(.TempNum) номер шаблона по массиву
    aGroupPos(g - 0) = -1               '(.TempItm) номер элемента в шаблоне
    sTerm = Source                      '
    sName = cPref & (g \ gStep): cGroups.Add sTerm, sName     ' добавляем в коллекцию
    
    Result = True: If Not UsePlaceHolders Then GoTo HandleExit
' если надо создавать шаблоны разбора выражений в скобках
Const cLBr = "[%", cRBr = "%]"  ' скобки для ссылок на элементы массива результата.
Dim jBeg As Long, jEnd As Long
Dim iLvl As Long, jLvl As Long
    i = g \ gStep: iMin = 1
    Do While i > iMin 'For i = i To 2 Step -1
' разбираем все нижестоящие элементы массива в обратном порядке
    ' элементы в массиве отсортированы так что наружные (те у которых Level меньше) будут выше
    ' проверяем - если границы проверяемого (j) элемента лежат внутри разбираемого (i)
    ' заменяем содержимое проверяемого элемента в разбираемом на символьный указатель
    ' смещаем позицию границы проверки в разбираемом элементе до границ неразобранного фрагмента
            j = iMin
        ' текст фaGroupPos(g + 2)рагмента до разбора
            sName = cPref & i
            sTerm = cGroups(sName)
        ' уровень и границы разбираемого фрагмента в исходной строке
            g = (i - 1) * gStep + 1
            iLvl = aGroupPos(g + 0)
            iBeg = aGroupPos(g + 1)
            iEnd = aGroupPos(g + 2)
        Do While j < i 'For j = 1 To i - 1
    ' проверяем все нижестоящие элементы массива в прямом порядке по разбираемому
        ' уровень и границы разбираемого фрагмента в исходной строке
            g = (j - 1) * gStep + 1
        ' проверяемый элемент должен принадлежать предыдущему уровню вложенности относительно разбираемого
            jLvl = aGroupPos(g + 0): If iLvl <> (jLvl - 1) Then GoTo HandleNextJ    'iLvl > jLvl -> Next j
        ' границы проверяемого элемента должены лежать в пределах границ разбираемого
            jBeg = aGroupPos(g + 1): If iBeg > jBeg Then GoTo HandleNextJ           'iBeg > jBeg -> Next j
            jEnd = aGroupPos(g + 2): If iEnd < jEnd Then GoTo HandleNextJ           'iEnd < jEnd -> Next j
        ' если прямой перебор j
            ' нужно считать от конца строки (начало фрагмента меняется)
            sTerm = Left$(sTerm, Len(sTerm) - (iEnd - jBeg)) & cLBr & j & cRBr & Right$(sTerm, iEnd - jEnd)
        ' и сдвигать нижнюю границу просматриваемого фрагмента
            iBeg = aGroupPos(g + 3) + 1     ' смещаем позицию на начало неразобранного фрагмента на позицию после найденной
            If j = iMin Then iMin = j + 1   ' смещаем указатель нижней границы проверяемых элементов массива
                                            ' (найденный нижний элемент уже не встретится нет смысла его проверять снова)
        '' если обратный перебор j
        '    ' нужно считать от начала строки (конец фрагмента меняется)
        '    ??? 'sTerm = Left$(sTerm, (iEnd - jBeg + 1)) & cLBr & j & cRBr & Right$(sTerm, Len(sTerm) - iBeg - jEnd)
        '    ' и сдвигать верхнюю границу просматриваемого фрагмента
        '    iEnd = aGroupPos(g + 4) - 1      ' смещаем позицию на конец неразобранного фрагмента на позицию до найденной
        '    ??? 'If j = iMin Then iMin = j   '
        ' проверяем полностью ли разобран фрагмент
            If iEnd <= iBeg Then Exit Do   ' разбор текущего фрагмента окончен
            If i = iMin Then iMin = i + 1   ' ??? смещаем указатель нижней границы проверяемых элементов массива
                                            ' (полностью разобранный нижний элемент уже не встретится нет смысла его проверять снова)
HandleNextJ: j = j + 1
    Loop 'Next j
    ' возвращаем результат разбора в коллекцию
        With cGroups: .Remove sName: .Add sTerm, sName, After:=i - 1: End With
HandleNextI: i = i - 1
    Loop 'Next i

HandleExit:     GroupsGet2 = Result: Exit Function
HandleError:    Select Case Err
    Case errUnclosedExp:    Debug.Print "Ошибка! Незавершённое выражение """ & sTerm & """ в позиции " & i & " в строке: """ & Source & """"
    Case errIncompleteExp:  Debug.Print "Ошибка! """ & sTerm & """ без """ & sName & """ в позиции " & i & " в строке: """ & Source & """"
    End Select
Stop: Resume 0
    Result = False: Err.Clear: Resume HandleExit
End Function

Public Function DeclineWordXml( _
    ByVal Word As String, _
    Optional NewCase As DeclineCase = DeclineCaseRod, _
    Optional NewNumb As DeclineNumb = DeclineNumbSingle, _
    Optional ByRef NewGend As DeclineGend = DeclineGendUndef, _
    Optional ByRef Animate As Boolean = False, _
    Optional IsFio As Byte = 0, _
    Optional ByRef SymbCase As Integer = 0, Optional ByRef Template As String _
    ) As String
' склонение слова. (эксперимент по переводу правил в XML)
'-------------------------
' Word - существительное в единственном числе именительном падеже
' NewCase - падеж ("р","д","в","т","п")
' NewNumb - число ("ед","мн")
' NewGend - род ("м","ж")
' Animate - признак (одушевленное","неодушевленное)
' IsFio - признак ФИО (0-не ФИО, 1-Фамилия, 2-Имя, 3-Отчество)
' SymbCase, Template - состояние регистра символов исходного слова и шаблон
'   SymbCase = 0 - не определено
'   SymbCase = 1 (vbUpperCase) - все символы в верхнем регистре
'   SymbCase = 2 (vbLowerCase) - все символы в нижнем регистре
'   SymbCase = 3 (vbProperCase) - первый символ в верхнем остальные, - в нижнем регистре
'   SymbCase =-1  регистр символов определяется по шаблону Template (часть букв в верхнем, часть - в нижнем регистре)
'-------------------------
' всё это пока очень неудачный эксперимент, но с потенциалом
'-------------------------
' ToDo: нужна более продуманая структура XML правил, оптимизировать сам алгоритм обработки
'-------------------------
Dim Result As String
    On Error GoTo HandleError
' подготавливаем слово
    Word = Trim$(Word): Result = LCase$(Word)
' получаем шаблон регистра символов слова
    If SymbCase = 0 Then SymbCase = p_GetSymbCase(Word, Template)
' дополнительное ограниичение: если длина слова < 3 и последняя гласная - лучше не склонять
    If Len(Result) < 3 Then If InStr(1, c_strSymbRusVowel, Right$(Result, 1)) Then GoTo HandleExit
' обрабатываем входные параметры
    If NewCase = DeclineCaseUndef Then NewCase = DeclineCaseImen Else If ((NewCase > DeclineCasePred) Or (NewCase < DeclineCaseImen)) Then Err.Raise vbObjectError + 512
    If IsFio Then Animate = True ' определять одушевленные не умеем, однако ФИО - однозначно одушевленные
' преобразуем параметры функции во внутренний формат для удобства обработки
Dim lngAttr1 As Long ' переменная для хранения аттрибутов выходного слова
' структура битов аттрибутов:
    lngAttr1 = Pwr2(NewCase - 1)                                                '[0-7]  - Case:  1-6
    If NewGend > DeclineGendUndef Then lngAttr1 = lngAttr1 Or Pwr2(NewGend + 7) '[8-10] - Gend:  1-3
    If NewNumb = DeclineNumbPlural Then lngAttr1 = lngAttr1 Or &H800            '[11]   - Numb:  1,2
    If Animate Then lngAttr1 = lngAttr1 Or (&H1000 And Pwr2(IsFio + 12))        '[12]   - Anim: 2;    [13-15] - IsFio: 1-3
' склонение слова
    Result = p_DeclineWord(Result, lngAttr1)
' восстановление регистра символов и возвращение результата
HandleExit:     Result = p_SetSymbCase(Result, SymbCase, Template)
                DeclineWordXml = Result: Exit Function
HandleError:    Err.Clear: Resume HandleExit
End Function

Private Function p_DeclineRules() As Object
' возвращает объект xmlDoc содержащий правила склонения
'-------------------------
' для проверки правильности правил: https://popadezham.ru/
'-------------------------
' теги:
'   <noun>,<verb> etc - верхний тег - часть речи его атрибуты применимы к подчиненным узлам (если не переопределены)
' атрибуты признаков:
'   case - падеж        (ирдвтп)
'   gend - род/число    (мжc/н)       н - множественное число
'   pers - лицо         (123)
'   anim - признак одушевленности (н/о/Ф/И/О), >1 - признак ФИО: 2-"Ф", 3-"И", 4-"О")
'   prevpart - в некоторых случаях надо знать часть речи предыдущего слова
'-------------------------
Dim sxmlRules As String:
Const cstrXmlBeg = "'=== XML BEG ===", cstrXmlEnd = "'=== XML END ==="  ' метки начала/конца XML вставки
Const cstrComBeg = "<!-- ", cstrComEnd = " -->"                         ' метки начала/конца XML комментария
    On Error GoTo HandleError
'-------------------------
' XML правила
'-------------------------
'=== XML BEG ===
'<?xml version='1.0' encoding='utf-8'?>
'<main>
'    <noun>
'    <!-- СУЩЕСТВИТЕЛЬНЫЕ -->
'        <!-- '
'          ----------------------------------------------------------------------
'          Падеж   Вопрос       1 скл          2 скл       3 скл       мн.ч.
'          ----------------------------------------------------------------------
'          Имен    кто? что?       -а,-я       -,-о,-е     -           -ы,-и,
'                                                                      -а,-я
'          Род     кого? чего?     -ы,-и       -а,-я       -и          -,-ов,
'                                                                      -ев,-ей
'          Дат     кому? чему?     -е,-и       -у,-ю       -и          -ам,-ям
'          Вин     кого? что?      -у,-ю       -,-а,-о,    -           -,-ы,
'                                              -е,-я                   -и,-а,-я,
'                                                                      -ов,-ев,-ей
'          Твор    кем? чем?       -ой(-ою),   -ом,        -ю          -ами, -ями
'                                  -ей(-ею),   -ем(-ём)
'                                  -ёй(-ёю)
'          Пред    о ком? о чём?   -е,-и       -е,-и       -и          -ах,-ях
'          ----------------------------------------------------------------------
'          https://kartaslov.ru/просклонять-существительное/
'        ' -->
'        <decline>
'        <!-- СКЛОНЯЮТСЯ ПО ПРАВИЛАМ -->
'            <!-- 1 склонение -->
'            <_а case='и'><_ы case='и' gend='н'/>
'              <_ы case='р'/><_ case='р' gend='н'/>
'              <_е case='д'/><_ам case='д' gend='н'/>
'              <_у case='в'/><_ case='в' gend='н'/>
'              <_ой case='т'/><_ами case='т' gend='н'/>
'              <_е case='п'/><_ах case='п' gend='н'/>
'            <!-- отдельные случаи на -а !!! только заготовка требует внимательной ревизии !!! -->
'              <_йка case='и'><_йки case='р'/><_ек case='р' gend='н'/></_йка>
'              <_йга case='и'><_йги case='р'/></_йга>
'              <_чка case='и'><_чки case='р'/></_чка>
'              <_шка case='и'><_шки case='р'/></_шка>
'              <_жка case='и'><_жки case='р'/></_жка>
'              <_цка case='и'><_цки case='р'/></_цка>
'              <_ча case='и'><_и case='в' gend='н'/><_ей case='в' gend='н' anim='о'/></_ча>
'              <_ща case='и'><_и case='в' gend='н'/><_ей case='в' gend='н' anim='о'/></_ща>
'              <_ца case='и'><_ы case='в' gend='н'/><_ей case='в' gend='н' anim='о'/></_ца>
'              <_ва case='и'></_ва>
'              <_на case='и'></_на>
'            <!-- женские фамилии на -ва, -на -->
'              <_ва case='и' anim='Ф'><_вой case='р'/></_ва>
'              <_на case='и' anim='Ф'><_ной case='р'/></_на>
'            </_а>
'            <_я case='и'><_и case='и' gend='н'/>
'              <_и case='р'/><_ей case='р' gend='н'/>
'              <_е case='д'/><_ям case='д' gend='н'/>
'              <_ю case='в'/><_и case='в' gend='н'/>
'              <_ей case='т'/><_ями case='т' gend='н'/>
'              <_е case='п'/><_ях case='п' gend='н'/>
'            <!-- отдельные случаи на -я -->
'              <_ия case='и'><_ий case='р' gend='н'/><_ии case='дп'/></_ия>
'              <_ья case='и'><_ей case='р' gend='н'/><_ье case='дп'/></_ья>
'            </_я>
'            <!-- 2 склонение -->
'            <_>
'            </_>
'            <_о case='и'><_а case='и' gend='н'/>
'              <_а case='р'/><_ов case='р' gend='н'/>
'              <_у case='д'/><_ам case='д' gend='н'/>
'              <_о case='в'/><_а case='в' gend='н'/>
'              <_ом case='т'/><_ами case='т' gend='н'/>
'              <_е case='п'/><_ах case='п' gend='н'/>
'            <!-- отдельные случаи на -о -->
'            </_о>
'            <_е case='и'><_я case='и' gend='н'/>
'              <_я case='р'/><_ей case='р' gend='н'/>
'              <_ю case='д'/><_ям case='д' gend='н'/>
'              <_е case='в'/><_я case='в' gend='н'/>
'              <_ем case='т'/><_ями case='т' gend='н'/>
'              <_е case='п'/><_ях case='п' gend='н'/>
'            <!-- отдельные случаи на -е -->
'            </_е>
'            <!-- 3 склонение -->
'            <_>
'            </_>
'        <!-- СКЛОНЯЮТСЯ ОСОБО -->
'        <!-- '
'          все парные существительные в родительном падеже имеют нулевое окончание (сапоги - сапог, брюки — брюк).
'            исключения: 'носки' и 'гольфы' (носки - носков)
'          - Слова домишко, заборишко (мужского рода) и т. п. склоняются по типу имен существительных мужского-среднего рода: домишко, домишка, домишку, домишко, домишком, о домишке. Формы косвенных падежей домишки, домишке, домишку, домишкой являются разговорными и восходят к начальной форме домишка (ср. у Некрасова: Артикул ружьем выкидывал, так что весь домишка вздрагивал).
'          - Слово домище имеет в именительном падеже множественного числа форму домищи.
'          - Сложные имена существительные, первый компонент которых образован числительным пол (половина), типа полчаса, полдюжины, пол-арбуза имеют в косвенных падежах (кроме винительного, совпадающего с именительным) двоякого рода формы: в книжной речи пол меняется на полу, а в разговорной может сохраняться без изменения. Ср.:
'            а) от получаса не осталось ни одной минуты; к полудюжине карандашей добавлено еще три; в полуарбузе было три килограмма веса; Я уже более полугода не бывал у них (Аксаков); Учитель невольно остановился на полуслове (Телешов);
'            б) растворить лекарство в полстакане воды; ограничиться полдюжиной карандашей; На полслове он обрывал и тер себе лоб… (А. Н. Толстой); Полгодом позже я написал навеянное одной из этих поездок стихотворение… (Симонов); В полверсте, в кустах — противник (Твардовский).
'          - Сложносоставные слова типа плащ-палатка, кран-балка, капитан-директор с тесно слившимися частями склоняются только во второй части: укрыться плащ-палаткой, около кран-балки, беседа с капитан-директором флотилии, в «Роман-газете» напечатано.
'            При меньшей спаянности составных частей возможны параллельные падежные формы: в разговорной речи склоняется только вторая часть, в книжной — обе части; ср.: в вагон-ресторане — в вагоне-ресторане, на матч-турнире — на матче-турнире, в разгаре бал-маскарада — в разгаре бала-маскарада. Ср. также: у капитан-лейтенанта — у инженера-экономиста (в первом случае слитный термин, во втором — сочетание определяемого слова и приложения при нем).
'            В сочетании Москва-река в книжной речи склоняются обе части (на Москве-реке, за Москвой-рекой), в разговорной — первая часть в косвенных падежах сохраняет начальную форму (на Москва-реке, за Москва-рекой).
'          - В сложных географических названиях первая часть в одних случаях склоняется, в других — остается без изменений; ср.: в Орехове-Зуеве, в Покровском-Стрешневе, во Владимире-Волынском — в Каменец-Подольске, в Гусь-Хрустальном.
'          - В сочетаниях типа пятое марта (образовано от сочетания «пятое число месяца марта» склоняется только первая часть: к пятому марта (не «к пятому марту»).
'        ' -->
'        <!-- разносклоняемые (имеют окончания разных склонений) -->
'            <время gend='с'></время>
'            <бремя gend='с'></бремя>
'            <стремя gend='с'></стремя>
'            <племя gend='с'></племя>
'            <пламя gend='с'></пламя>
'            <полымя gend='с'></полымя>
'            <знамя gend='с'></знамя>
'            <темя gend='с'></темя>
'            <семя gend='с'></семя>
'            <имя gend='с'></имя>
'            <вымя gend='с'></вымя>
'            <дитя gend='с'></дитя>
'            <путь gend='м'></путь>
'        <!-- склоняющиеся по адъективному типу -->
'            <рядовой gend='м'></рядовой>
'            <запятая gend='ж'></запятая>
'            <животное gend='с'></животное>
'            <дежурный gend='м'></дежурный>
'            <столовая gend='ж'></столовая>
'            <мороженое gend='с'></мороженое>
'        <!-- склоняющиеся по местоимённому типу -->
'            <ничья gend='ж'></ничья>
'            <кабельтов gend='м'></кабельтов>
'        <!-- не имеют формы единственного числа -->
'            <ножницы gend='н'></ножницы>
'            <дрова gend='н'></дрова>
'            <щипцы gend='н'></щипцы>
'        <!-- прочие -->
'            <тайга gend='ж'><таёг case='р' gend='н'/></тайга>
'            <номер case='ив' gend='м'><номера gend='н'/></номер>
'        </decline>
'        <excepts>
'        <!-- НЕ СКЛОНЯЮТСЯ -->
'            <метро/><пальто/><кенгуру/><зебу/><колибри/><сулугуни/><драже/>
'            <трюмо/><каноэ/><алоэ/><шасси/><такси/><жалюзи/><бра/>
'            <!-- фамилии и имена на -о, отчества на -оглы, ага и т.п.  -->
'            <_о anim='ФИ'/><_оглы anim='О'/><_кызы anim='О'/>
'        </excepts>
'        <replace>
'        <!-- ЗАМЕНА/(ВЫПАДЕНИЕ) гласной при склонении -->
'        <!-- '
'             в старшем теге можно прописать атрибуты параметров замены общие для группы
'                str - строка на которую необходимо заменить
'                pos - начало позиции замены с начала либо (-) с конца слова
'                len - длина заменяемого фрагмента (если опущено =1)
'        ' -->
'            <replace pos='-2' str='ь'>
'            <!-- замена гласной (2-я с конца) е->ь -->
'                <лев case='рдвтп'/><лев gend='н'/>
'                <лёд case='рдтп'/><лёд gend='н'/>
'                <лён case='рдтп'/><лён gend='н'/>
'            </replace>
'            <replace pos='-2' str=''>
'            <!-- выпадение гласной (2-я с конца) -->
'                <павел case='рдвтп'/>
'                <котёл case='рдвтп'/>
'                <осёл case='рдвтп'/>
'                <костёр case='рдвтп'/>
'                <угол case='рдтп'/><угол gend='н'/>
'                <конец case='рдтп'/><конец gend='н'/>
'                <лоб case='рдтп'/><лоб gend='н'/>
'                <сон case='рдтп'/><сон gend='н'/>
'                <рот case='рдтп'/><рот gend='н'/>
'                <потолок case='рдтп'/><потолок gend='н'/>
'            </replace>
'            <replace pos='-3' str=''>
'            <!-- выпадение гласной (3-я с конца) -->
'                <пень case='рдтп'/><пень gend='н'/>
'                <уголь case='рдтп'/><уголь gend='н'/>
'                <день case='рдтп'/><день gend='н'/>
'                <огонь case='рдтп'/><огонь gend='н'/>
'                <ложь case='рдп' gend='ж'/><ложь gend='н'/>
'                <рожь case='рдп' gend='ж'/><рожь gend='н'/>
'            </replace>
'        </replace>
'    </noun>
'    <adjective>
'    <!-- ПРИЛАГАТЕЛЬНЫЕ -->
'        <!-- '
'          на: -ая, яя, ую, юю, ое, ее, оё, её, иё, ий, ый, ой, ие
'          кроме: стая, зая..
'          очень много на -ий: гелий, калий, литий и т.п.
'          очень много на -ие: событие, прибытие, наитие..
'          очень много на -ой: покой, прибой, забой, запой, отстой..
'          ----------------------------------------------------------------------
'          Падеж      муж             жен             средн           мн.ч.
'          ----------------------------------------------------------------------
'          Имен       какой?          какая?          какое?          какие?
'                     -ой,-ый,-ий     -ая,-яя         -ое,-ее         -ые,-ие
'          Род        какого?         какой?          какого?         каких?
'                     -ого,-ого,-его  -ой,-ей         -ого,-его       -ых,-их
'          Дат        какому?         какой?          какому?         каким?
'                     -ому,-ому,-ему  -ой,-ей         -ому, -ему      -ым,-им
'          Вин        какой?,какого?  какую?          какое?          какие?,каких?
'                     -ой,-ый,-ий     -ую,-юю         -ое,-ее         -ые,-ии
'                     -ого,-ого,-его                                  -ых,-их
'          Твор       каким?          какой?          каким?          какими?
'                     -ым,-ым,-им    -ой,-ей         -ым,-им          -ыми,-ими
'          Пред       о каком?        о какой?        о каком?        о каких?
'                     -ом -ом -ем     -ой -ей         -ом -ем         -ых -их
'        ' -->
'        <decline>
'        </decline>
'        <excepts>
'        </excepts>
'    </adjective>
'    <numeral>
'    <!-- ЧИСЛИТЕЛЬНЫЕ -->
'        <!-- '
'           ноль, нуль, один, два, три, четыре, пять, шесть, семь, восемь, девять, десять,
'   -дцать: одиннадцать, двенадцать, тринадцать, четырнадцать, пятнадцать, шестнадцать,
'           семнадцать, восемнадцать, девятнадцатьдвадцать, тридцать,
'   -десят: пятьдесят, шестьдесят, семьдесят, восемьдесят
'           сорок, девяносто, сто, двести, триста, четыреста, пятьсот, шестьсот, семьсот, восемьсот, девятьсот, _
'           тысяча, миллион, миллиард, триллион, квадриллион, квинтиллион, секстиллион, септиллион, октиллион, нониллион, дециллион)
'
'           нулевой, первый, второй, третий, четвёртый, пятый, шестой, седьмой, восьмой, девятый, десятый,
'           сотый , сороковой, девяностый, тысячный, миллионный, миллиардный, триллионный

'           треть, четверть
'           и т.п.
'        ' -->
'        <decline>
'        </decline>
'        <excepts>
'        </excepts>
'    </numeral>
'    <adverb>
'    <!-- НАРЕЧИЯ -->
'        <decline>
'        </decline>
'        <excepts>
'        </excepts>
'    </adverb>
'    <verb>
'    <!-- ГЛАГОЛЫ -->
'        <!-- нет и не планируется. просто на всякий случай -->
'        <!-- '
'          на -ть кроме: сеть, сыть, несыть, ять, мать, зять, рать, бать, гать, тать, геть
'               муть, суть, путь, жуть, чуть, круть, круть-верть,
'               копоть, коготь, ноготь, лапоть, дёготь,
'               нежить, пажить, сыть, нить...
'               месть, жесть, лесть, тесть, честь, часть, страсть,
'               пять, шесть, девять, десять, треть, четверть
'          на -ти кроме: дети, сети, йети, конфети, части, страсти, напасти..
'          на -чь кроме: дичь, дочь, ночь, прочь, картечь...
'          на -ся кроме: дуся, вася, ася, мася, муся, пуся...
'          Некоторые на - у(-ю), -ит, -ишь, -им, -ать(-ять), -ите: чую, дую, видит, видишь, видим, видать
'               и т.п.
'          Некоторые могут трактоваться двояко как существ. и как глагол (важен контекст):
'               напасть, пропасть, стать, жать и др.
'               речь, печь, сечь, течь..
'       СПРЯЖЕНИЯ (conjugation):
'          ----------------------------------------------------------------------
'           1 спряжение:
'          ----------------------------------------------------------------------
'          на  -еть:  велеть, белеть    и т.п. кроме: вертеть, видеть, зависеть, обидеть, ненавидеть, смотреть, терпеть.
'          на  -ать:  бежать, смешать   и т.п. кроме: гнать, дышать, держать, слышать.
'          на  -оть, -уть, -ть:  пороть, молоть, гнуть, обмануть  и т.п.
'          на  -ить:   cтелить, брить, зыбиться, зиждиться (исключения из 2 спряжения)
'          ----------------------------------------------------------------------
'          Число и лицо             Окончание   Пример
'          ----------------------------------------------------------------------
'          Ед.  1 – я               -у,-ю       хлопочу
'               2 – ты              -ешь        хлопочешь
'               3 – он, она, оно    -ет         хлопочет
'          Мн.  1 – мы              -ем         хлопочем
'               2 – вы              -ете        хлопочете
'               3 – они             -ут,-ют     хлопочут
'          ----------------------------------------------------------------------
'           2 спряжение:
'          ----------------------------------------------------------------------
'          на  -ить:  молить, убить, рубить  и т.п. кроме: cтелить, брить, зыбиться, зиждиться
'          на  -еть:  вертеть, видеть, зависеть, обидеть, ненавидеть, смотреть, терпеть (исключения из 1 спряжения)
'          на  -ать:  гнать, дышать, держать, слышать (исключения из 1 спряжения)
'          на  -у(-ю),-ит,-ишь,-им,-ать (-ять),-ите: смотрю, смотрит, едим, стоять, смотрите, молите и т.п.
'          ----------------------------------------------------------------------
'          Число и лицо             Окончание   Пример
'          ----------------------------------------------------------------------
'          Ед.  1 – я               -у,-ю       медлю
'               2 – ты              -ишь        медлишь
'               3 – он, она, оно    -ит         медлит
'          Мн.  1 – мы              -им         медлим
'               2 – вы              -ите        медлите
'               3 – они             -ат,-ят     медлят
'          ----------------------------------------------------------------------
'        ' -->
'        <conjugation>
'        <!-- СПРЯГАЮТСЯ ПО ПРАВИЛАМ -->
'        <!-- Нет и не планируется. просто на всякий случай -->
'        <!-- 1 спряжение -->
'        <!-- 2 спряжение -->
'        </conjugation>
'        <excepts>
'        </excepts>
'    </verb>
'    <pronoun>
'    <!-- МЕСТОИМЕНИЯ -->
'        <decline>
'             <я  case='и' anim='о' pers='1'><мы case='и' gend='н'/>
'            <!-- Личные (1 лицо):  я, мы -->
'                <меня case='рв'/><мне case='д'/><мной case='т'/><мне case='п'/>
'                <нас case='рв' gend='н'/><нам case='д' gend='н'/>
'                <нам case='т' gend='н'/><нас case='п' gend='н'/>
'            </я>
'            <ты case='и' anim='о' pers='2'><вы case='и' gend='н'/>
'            <!-- Личные (2 лицо):  ты, вы -->
'                <тебя case='рв'/><тебе case='д'/><тобой case='т'/><тебе case='п'/>
'                <вас case='рв' gend='н'/><вам case='д' gend='н'/>
'                <вами case='т' gend='н'/><вас case='п' gend='н'/>
'            </ты>
'            <он gend='м' pers='3'><она gend='ж'/><оно gend='с'/><они gend='н'/>
'            <!-- Личные (3 лицо):  он, она, оно, они -->
'                <его case='рв'/><её case='рв' gend='ж'/><их case='рвп' gend='сн'/>
'                <ему case='д'/><ей case='д' gend='ж'/><им case='д' gend='сн'/>
'                <ей case='т' gend='ж'/><им case='т'/><ими case='т' gend='сн'/>
'                <нём case='п'/><ей case='п' gend='ж'/>
'            </он>
'            <он prevpart='preposition' gend='м' pers='3'>
'            <!-- 'н' обязательно после предлогов! как проверять пока не решил -->
'                <она gend='ж'/><оно gend='с'/><они gend='н'/>
'                <него case='рв'/><неё case='рв' gend='ж'/><них case='рвп' gend='мс'/>
'                <нему case='д'/><ней case='дпт' gend='ж'/><ним case='д' gend='с'/><ним case='т' gend='м'/>
'                <ним case='д' gend='н'/><ними case='т' gend='с'/><ними case='т' gend='н'/><нём case='п'/>
'            </он>
'            <себя>
'                <!-- Возвратное:  себя -->
'                <себя case='рв'/><себе case='д'/><собой case='т'/><себе case='п'/>
'            </себя>
'            <!-- Притяжательные:  мой,  твой,  свой,  наш,  ваш -->
'            <!-- Указательные:  этот,  тот,  такой,  таков,  таковой,  этакий;  столько;  оба (обе);  устаревшие:  сей,  оный -->
'            <этот gend='м'>
'                <эта gend='ж'/><эту case='в' gend='ж'/><это case='ив' gend='с'/><эти gend='н'/>
'                <этого case='рв' gend='м'/><этого case='р' gend='с'/><этой case='рдпт' gend='ж'/>
'                <этих case='рв' gend='н'/><этому case='д' gend='мс'/><этих case='рвп' gend='н'/>
'                <этим case='т' gend='мс'/><этим case='д' gend='н'/><этими case='т' gend='н'/><этом case='п' gend='мс'/>
'            </этот>
'            <тот gend='м'>
'                <та case='и' gend='ж'/><то case='ив' gend='с'/><те case='и' gend='н'/>
'                <того case='рв'/><того case='р' gend='с'/><той case='рд' gend='ж'/><тех case='рвп' gend='н'/>
'                <тому case='д'/><ту case='в' gend='ж'/><той case='тп' gend='ж'/><том case='п' gend='мс'/>
'                <тому case='д' gend='с'/><тем case='д' gend='н'/><тем case='т' gend='мс'/><теми case='т' gend='н'/>
'            </тот>
'            <!-- Определительные: каждый,  весь (все, всё),  всяк,  всякий,  всяческий,  самый,  сам,  иной,  другой -->
'            <!-- Вопросительные: кто?  что?  какой?  который?  чей?  сколько? -->
'            <!-- Относительные — это те же вопросительные, но не имеющие вопросительного знака, а употребляемые для связи частей сложноподчинённых предложений. Слово  каковой  употребляется только как относительное местоимение -->
'            <!-- '
'             Неопределённые: некто, нечто, некоторый, некий;
'                                     несколько,  сколько-то,  сколько-нибудь;
'                                     кто-то,  что-то,  чей-то,  какой-то,  который-то;
'                                     кто-либо,  что-либо,  чей-либо,  какой-либо,  который-либо;
'                                     кто-нибудь,  что-нибудь,  чей-нибудь,  какой-нибудь,  который-нибудь;
'                                     кое -кто, кое - что, кое - какой
'            ' -->
'            <!-- Отрицательные:  никто, ничто, никакой, ничей, нисколько, некого, нечего -->
'        </decline>
'        <excepts>
'        </excepts>
'    </pronoun>
'    <preposition>
'    <!-- ПРЕДЛОГИ -->
'        <excepts>
'            <!-- НЕ СКЛОНЯЮТСЯ -->
'            <в/><с/><к/><у/><а/><и/><о/><об/><на/><по/><во/><за/><от/><не/><ни/><ли/>
'            <или/><еле/><над/><при/><под/><для/><через/><перед/><ввиду/><наподобие/><вроде/><вблизи/>
'            <вглубь/><вдоль/><возле/><около/><среди/><вокруг/><внутри/><впереди/><после/><насчет/><навстречу/>
'            <вслед/><вместо/><ввиду/><благодаря/><вследствие/>
'        </excepts>
'    </preposition>
'</main>
'=== XML END ===
'-------------------------
'' старые правила
'-------------------------
'-------------------------
HandleStart:
' читаем текст из текущей процедуры между метками
Dim lngBegLine As Long, lngBegCol As Long, lngEndLine As Long, lngEndCol As Long
Dim strTemp As String
Dim bolFound As Boolean
    With Application.VBE.ActiveVBProject.VBComponents(c_strModule).CodeModule
        lngBegCol = 1: lngEndCol = -1
        lngBegLine = .ProcBodyLine(c_strProcedure, 0)      'vbext_pk_Proc
   ' ищем начало вставки
        Do
            lngBegLine = lngBegLine + 1
            bolFound = .Find(cstrXmlBeg, lngBegLine, lngBegCol, .ProcBodyLine(c_strProcedure, 0) + .ProcCountLines(c_strProcedure, 0) - 1, -1)
            If Not bolFound Then Err.Raise vbObjectError + 512
            If lngBegCol = 1 Then Exit Do ' начало найдено
        Loop
   ' ищем конец вставки
        lngEndLine = lngBegLine
        Do
            lngEndLine = lngEndLine + 1
            bolFound = .Find(cstrXmlEnd, lngEndLine, lngBegCol, .ProcBodyLine(c_strProcedure, 0) + .ProcCountLines(c_strProcedure, 0) - 1, -1)
            If Not bolFound Then Err.Raise vbObjectError + 512
            If lngBegCol = 1 Then Exit Do ' конец найден
        Loop
   ' читаем строки в переменную
        sxmlRules = vbNullString
        lngBegLine = lngBegLine + 1
        lngEndLine = lngEndLine '- 1
        Do While lngBegLine < lngEndLine
            ' получаем содержимое строки
            strTemp = VBA.RTrim$(VBA.Trim$(VBA.Mid$(.Lines(lngBegLine, 1), 2)))
            ' проверяем не является ли строка строкой комментария
            lngBegCol = InStr(1, strTemp, cstrComBeg)
            If lngBegCol > 0 Then
            ' если есть начало - ищем конец комментария
                lngEndCol = -1
                strTemp = VBA.RTrim$(VBA.Left$(strTemp, lngBegCol - 1))   ' отсекаем хвост
                If Not .Find(cstrComEnd, lngBegLine, 1, lngEndLine - 1, lngEndCol) Then Err.Raise vbObjectError + 512
            ' надо отсечь начало
                If (lngEndCol < Len(.Lines(lngBegLine, 1))) Then strTemp = VBA.RTrim$(VBA.Mid$(.Lines(lngBegLine, 1), lngEndCol))
            End If
            If Len(Trim(strTemp)) > 0 Then sxmlRules = sxmlRules & strTemp & vbCr       ' добавляем в выходную строку (не комментарий)
            lngBegLine = lngBegLine + 1
        Loop
    End With
'-------------------------
' инициализация документа XML
'-------------------------
Dim xmlDoc As Object: Set xmlDoc = CreateObject("MSXML2.DOMDocument")
    With xmlDoc
        .SetProperty "SelectionLanguage", "XPath"
        .LoadXml (sxmlRules)
        If Len(.XML) = 0 Then Err.Raise vbObjectError + 512 'GoTo HandleStart
    End With
    Set p_DeclineRules = xmlDoc
HandleExit:  Exit Function
HandleError: Err.Clear: Resume HandleExit
End Function
Private Function p_DeclineRuleData(xmlNod As Object, _
    Optional nodType As Long, _
    Optional nodData As Long, _
    Optional nodPart As SpeechPartType, _
    Optional colParams As Collection) As Boolean
' возвращает параметры узла правил
'-------------------------
' nodText   - значение
' nodType   - тип правила /1-decline/2-replace/-1-excepts
' nodData   - аттрибуты узла правил. структура битов:
'   [0-7]     - Case: ирдвтп.. (два последних бита прозапас)
'   [8-10]    - Gend: мжс
'   [11]      - Gend: н (мн.ч.)
'   [12-15]   - Anim: оФИО(н=0)
' nodPart   - часть речи noun/adjective/..
' colParams - коллекция дополнительных аттрибутов узла (например параметры для replace)
'-------------------------
' также надо получить исходную форму слова
' лицо, др аттрибуты (?)
' желательно также параметром передавать параметры предыдущего и след слова
' действие и параметры действия
'-------------------------
Dim Result As Boolean ': Result = False
    On Error GoTo HandleError
'    nodName = xmlNod.nodeName
    nodType = 0: nodData = 0
    nodPart = SpeechPartTypeUndef
    Set colParams = New Collection
Dim tmpNod As Object: Set tmpNod = xmlNod
Dim tmpAtr, tmpVal, tmpNam As String
    Do Until tmpNod.parentNode.parentNode.parentNode Is Nothing
    ' перебираем узлы до старшего родительского
        ' если основные аттрибуты уже заполнены просто поднимаемся до старшего родителя
        'If (nodData And (DeclineAttrCase + DeclineAttrNumb + DeclineAttrGend)) <> (DeclineAttrCase + DeclineAttrNumb + DeclineAttrGend) Then
        ' иначе - заполняем недостающие аттрибуты
        With tmpNod
    ' читаем имя узла
            Select Case .nodeName
            Case "decline": nodType = nodType Or 1
            Case "replace": nodType = nodType Or 2
            Case "excepts": nodType = &HFFFFFFFF
            End Select
    ' читаем аттрибуты узла (аттрибут заполняем только в случае его отсутствия)
            For Each tmpAtr In .Attributes
                With tmpAtr
                    tmpVal = .nodeValue
                    tmpNam = .nodeName
                End With
                Select Case tmpNam
            ' читаем основные аттрибуты правила в nodData
                Case "case": If (nodData And &HFF) <> 0 Then GoTo HandleNextAtr
                ' падежи
                    Do While Len(tmpVal) > 0
                        Select Case Left$(tmpVal, 1)
                        Case "и": nodData = nodData Or 1 '2^0
                        Case "р": nodData = nodData Or 2 '2^1
                        Case "д": nodData = nodData Or 4 '2^2
                        Case "в": nodData = nodData Or 8 '2^3
                        Case "т": nodData = nodData Or &H10 '2^4
                        Case "п": nodData = nodData Or &H20 '2^5
                        'Case "?": nodData = nodData Or &H40 '2^6
                        'Case "?": nodData = nodData Or &H80 '2^7
                        End Select
                        tmpVal = Mid$(tmpVal, 2)
                    Loop
                Case "gend":  If (nodData And &HF00) <> 0 Then GoTo HandleNextAtr
                ' род/число
                    Do While Len(tmpVal) > 0
                        Select Case Left$(tmpVal, 1)
                        Case "м": nodData = nodData Or &H100 '2^8
                        Case "ж": nodData = nodData Or &H200 '2^9
                        Case "с": nodData = nodData Or &H400 '2^10
                        Case "н": nodData = nodData Or &H800 '2^11
                        End Select
                        tmpVal = Mid$(tmpVal, 2)
                    Loop
                Case "anim": If (nodData And &HF000) <> 0 Then GoTo HandleNextAtr
                ' признак одушевлённости/ФИО
                    Do While Len(tmpVal) > 0
                        Select Case Left$(tmpVal, 1)
                        Case "о": nodData = nodData Or &H1000 '2^12
                        Case "Ф": nodData = nodData Or &H3000 '2^12+2^13
                        Case "И": nodData = nodData Or &H5000 '2^12+2^14
                        Case "О": nodData = nodData Or &H9000 '2^12+2^15
                        End Select
                        tmpVal = Mid$(tmpVal, 2)
                    Loop
                Case Else: If p_IsExist(.nodeName, colParams) Then GoTo HandleNextAtr
                ' читаем прочие аттрибуты и добавляем их по имени в colParams
                    ' для replace:
                    '   pos - позиция замены: (-) от конца слова; (+) - от начала
                    '   len - длина заменяемого фрагмента, по-умолчанию =1
                    '   str - строка которой следует заменить
                    ' прочие:
                    '   pers - лицо
                    '   prevpart часть речи предыдущего токена
                    colParams.Add tmpVal, tmpNam
                End Select
HandleNextAtr:
            Next tmpAtr
        End With
    ' переходим к родительскому узлу
        Set tmpNod = tmpNod.parentNode
    Loop
    ' получаем часть речи из имени старшего родительского узла
    Select Case tmpNod.nodeName
    Case "noun":        nodPart = SpeechPartTypeNoun
    Case "adjective":   nodPart = SpeechPartTypeAdject
    Case "numeral":     nodPart = SpeechPartTypeNumeral
    Case "verb":        nodPart = SpeechPartTypeVerb
    Case "adverb":      nodPart = SpeechPartTypeAdverb
    Case "pronoun":     nodPart = SpeechPartTypePronoun
    Case "preposition": nodPart = SpeechPartTypePreposition
    Case Else:          nodPart = SpeechPartTypeUndef
    End Select
    Result = True
HandleExit:  p_DeclineRuleData = Result: Exit Function
HandleError: Result = False: Err.Clear: Resume HandleExit
End Function
Private Function p_DeclineWord( _
    ByVal Word As String, _
    Optional Attr1 As Long _
    ) As String
' как бы склоняет/спрягает по заданным аттрибутам используя XML словарь правил
'-------------------------
' Word  - склоняемое слово
' Attr1 - аттрибуты желаемой формы слова
'   [0-7]   - Case
'   [8-10]  - Gend
'   [11]    - Numb
'   [12]    - Anim
'   [13-15] - IsFio
'-------------------------
Dim Result As String: Result = Word 'LCase$(Word)
    On Error GoTo HandleError
'-------------------------
' инициализация правил склонения
Static xmlDoc As Object: If xmlDoc Is Nothing Then Set xmlDoc = p_DeclineRules Else If Len(xmlDoc.XML) = 0 Then Set xmlDoc = p_DeclineRules
'-------------------------
Dim xmlNodes As Object, xmlNod As Object, xPath As String
Dim tmpType As Long             ' тип правила
Dim tmpAttr As Long             ' аттрибуты прочитанного правила
Dim tmpPart As SpeechPartType   ' часть речи
Dim colAttr As Collection       ' коллекция дополнительных аттрибутов правила
'   <noun>,<verb> etc - верхний тег - часть речи его атрибуты применимы к подчиненным узлам (если не переопределены)
'   для 'decline':      'case','gend','anim', (?)
'   для 'excepts':   то же
'   для 'replace':      то же + 'pos','len' и 'str'
'xPath = "//*[contains(name(),'Var')]"   ' все элементы подчинённые корневому содержащие в имени тега указанную строку
'xPath = "//*[@e='о']"                   ' все элементы с аттрибутом равным значению

' 1.Проверка по полному совпадению слова
HandleTestWhole:
    xPath = "//" & Result & "" '
    Set xmlNodes = xmlDoc.SelectNodes(xPath)
    If xmlNodes.Length > 0 Then
    ' если слово найдено в списке правил
        For Each xmlNod In xmlNodes
    ' перебираем совпадения и получаем реквизиты узла
            Call p_DeclineRuleData(xmlNod, tmpType, tmpAttr, tmpPart, colAttr)
    ' сравнить с ожидаемыми параметрами
Stop
    ' на один фрагмент может сработать несколько правил - нужен отбоор наиболее вероятных
        Next xmlNod
    ' Если нет совпадения по полному слову
    End If
' 2.Проверка по совпадению окончания слова
HandleTestEnd:
            
' 3.Обрабатываем по отобранным правилам
HandleApplyRules:
    For Each xmlNod In xmlNodes
        If tmpType = -1 Then
    ' excepts - слово несклоняется - прерываем обработку
        End If
        If tmpType And 1 = 1 Then
    ' decline - слово склоняется
            If tmpType And 2 = 2 Then
    ' replace - некоторые формы приводят к замене/выпадению символов
            End If
        End If
    Next xmlNod
Stop
' Проверка правил склонения (d)
    ' проверка по признаку совпадения: по полному слову/окончанию/началу/шаблону(?) (w/e/b/?)
    ' найденные совпадения проверяем на соответствие заданным условиям
    ' если соответствие не полное
    ' поднимаемся к старшему родителю и ищем среди его потомков
    ' отбираем наиболее подходящее совпадение
    ' из старшего родителя делаем Result (им.п., ед.ч., род берём по найденному)
    ' ищем и применяем для него правила модификации: замена/выпадение (r)
    ' склоняем в соответствии с отобранным совпадением
'Stop
'' !! экспериментальные варианты
'' Проверка особых случаев склонения (по полному совпадению слова)
'    'xPath = "//descendant-or-self::d[ancestor-or-self::d[d[@w='" & Result & "']]]" ' слово в списке особых случаев склонения
'    'xPath = "//d[@w='" & Result & "']/ancestor-or-self::d/descendant-or-self::d" ' слово в списке особых случаев склонения
'    Set xmlNodes = xmlDoc.SelectNodes(xPath)
'    If xmlNodes.Length > 0 Then
'    ' если слово найдено в списке особых случаев -
'    ' обрабатываем по найденному правилу
'        For Each xmlNod In xmlNodes
'        ' ищем среди подчинённых узел соотвествующий по аттрибутам заданным
'            attrRead = p_DeclineRuleData(xmlNod, tmpPart)
'' если аттрибут рода/числа не установлен в шаблоне устанавливаем его по прочитанному из узла
''Stop
'            ' проверяем соответствие прочитанного правила заданному параметрами функции
'            If (attrRead And attrTemp) = attrTemp Then
'            ' получаем из найденного правила результат соответствующий заданию
'                Result = xmlNod.getAttribute("w")
'                Exit For
'            End If
'        Next xmlNod
'        GoTo HandleExit    ' прерываем обработку
'    End If
'
' Подготовка к склонению
'Dim i As Long
'' 2.Проверка по подстроке
'
'
'    Do While i < Len(Result)
'    ' последовательно увеличивая проверяем окончания
'    ' пока не останется один вариант соответствующий всем условиям
''  <!-- шаблон склонения по окончанию
''    <d e='' case='0' numb='1'></d e='' case='0' numb='2'/> _
''      <d e='' case='1' numb='1'/><d e='' case='1' numb='2'/>
''      <d e='' case='2' numb='1'/><d e='' case='2' numb='2'/>
''      <d e='' case='3' numb='1'/><d e='' case='3' numb='2'/>
''      <d e='' case='4' numb='1'/><d e='' case='4' numb='2'/>
''      <d e='' case='5' numb='1'/><d e='' case='5' numb='2'/>
''    </d>
'        i = i + 1
'        xPath = "//*[@e='" & Right$(Result, i) & "']" ' совпадение окончаний слова
'        Set xmlNodes = xmlDoc.SelectNodes(xPath): If xmlNodes.Length < 2 Then Exit Do
'    Loop
Stop
' Отбор правил
    '' исключение по подстроке
    ''...
    '' исключение по условию
    ''...
' Последовательно перебираем правила которым соответствует слово
    ' пока не останется одно его и будем использовать

'' Получениение исходных аттрибутов узла/слова
' ...

'' Обработка окончаний и склонение по заданным параметрам
' ...
'' Проверка необходимости замены/выпадения букв
    '' при выпадении брать не Result, а исходное слово Word
    '' для сохранения шаблона регистра и потом преобразовывать его в Result
'    xPath = "//x[@w='" & Result & "']" ' слово в списке исключений (не склоняется)
'    Set xmlNodes = xmlDoc.SelectNodes(xPath)
'    If xmlNodes.Length > 0 Then
'    ' если слово найдено в списке замены/выпадения
'    '
'Stop
'    End If
'Stop
'    End If


Stop
HandleExit:     p_DeclineWord = Result: Exit Function
HandleError:    Err.Clear: Resume HandleExit
End Function

'-------------------------
Private Function p_GetWordTemplate(ByVal Word As String, Optional CheckCase As Boolean = False) As String
' Создает на шаблон слова для последующего анализа
'-------------------------
' CheckCase - определяет будет ли при создании шаблона учитываться регистр символа
'-------------------------
Dim Result As String: Result = vbNullString
    On Error GoTo HandleError
Dim sArr:   sArr = Array(c_strSymbRusSign & c_strSymbEngSign, c_strSymbRusVowel & c_strSymbEngVowel, c_strSymbRusConson & c_strSymbEngConson)
' заменяем символы исходной строки их обозначениями в паттерне (x, g, s)
Dim i As Long, j As Long, m As String, s As String
    s = "xgs" ' символы для подстановки
    For i = 1 To Len(Word)
    ' перебор символов слова
        m = Mid$(Word, i, 1)
        ' если учитываем регистр символа меняем регистр символов подстановки в соответствии с регистром символа
        If CheckCase Then If m = LCase(m) Then s = LCase(s) Else s = UCase(s)
        m = LCase$(m)
        For j = 0 To UBound(sArr)
        ' перебор элементов массива подстановки
            If InStr(sArr(j), m) Then Mid$(Word, i, 1) = Mid$(s, j + 1, 1): Exit For
    Next j, i
    Result = Word
HandleExit:  p_GetWordTemplate = Result: Exit Function
HandleError: Result = vbNullString: Err.Clear: Resume HandleExit
End Function


Private Function p_GetSymbCase(Word As String, Optional Template As String) As Integer
' возвращает состояние регистра символов слова
'-------------------------
Dim Result As Integer
    Result = False
    On Error GoTo HandleError
' 0 - не определено
    If Word = UCase$(Word) Then
' 1 (vbUpperCase) - все символы в верхнем регистре
        Result = vbUpperCase
    ElseIf Word = LCase$(Word) Then
' 2 (vbLowerCase) - все символы в нижнем регистре
        Result = vbLowerCase
    ElseIf Word = StrConv(Word, vbProperCase) Then
' 3 (vbProperCase) - первый символ в верхнем остальные, - в нижнем регистре
        Result = vbProperCase
    Else
'-1 - регистр символов определяется по шаблону (часть букв в верхнем, часть - в нижнем регистре)
    ' формируем шаблон регистра по слову
        Template = p_GetWordTemplate(Word, True): Result = -1
    End If
HandleExit:  p_GetSymbCase = Result: Exit Function
HandleError: Result = False: Err.Clear: Resume HandleExit
End Function

Private Function p_SetSymbCase(Word As String, SymbCase As Integer, Optional ByVal Template As String) As String
' устанавливает состояние регистра символов слова
'-------------------------
Dim Result As String
    Result = Word
    On Error GoTo HandleError
    Select Case SymbCase
    Case vbUpperCase:   Result = UCase$(Word)
    Case vbLowerCase:   Result = LCase$(Word)
    Case vbProperCase:  Result = StrConv(Word, vbProperCase)
    Case -1             ' форматируем по шаблону
' нафига это?? - нууу... - просто эксперимент - сам не знаю, а вдруг? )
' впрочем все равно это все пока сложно и неправильно,
' а случай с разнокалиберными регистрами в слове можно просто игнорировать
' в силу сильно упрощенного алгоритма определения окончаний часто работает не корректно
        ' формируем шаблон текущего слова и сравниваем их
        Dim s As String * 1, с As Integer
        Dim i As Long, iMax As Long: i = 1: iMax = Len(Template)
        Dim NewTemp As String: NewTemp = p_GetWordTemplate(Word, True)
        If LCase$(Template) = LCase$(NewTemp) Then
        ' если совпадают - форматируем по шаблону
            Do Until i > iMax
                s = Mid$(Template, i, 1)
                If LCase(s) = s Then
                    Mid$(Result, i, 1) = LCase$(Mid$(Result, i, 1))
                Else
                    Mid$(Result, i, 1) = UCase$(Mid$(Result, i, 1))
                End If
                i = i + 1
            Loop
        Else
        ' если нет приводим исходный шаблон к шаблону текущего слова
        Dim j As Long, jMax As Long: j = 1: jMax = Len(NewTemp)
        ' форматируем по следующему правилу
            ' если тип символа (xgs) приводимого (исходного) шаблона совпадает
            ' с типом шаблона нового слова форматируем как в приводимом шаблоне,
            ' если не совпадает - повторяем регистр предыдущего символа
            ' знаки ьъ форматируем как гласные
            Template = Replace$(Template, "x", "g"): NewTemp = Replace$(NewTemp, "x", "g")
            ' первый символ берем в регистре исходного шаблона
            s = Mid$(Template, i, 1)
            If LCase$(s) = s Then
                Mid$(Result, j, 1) = LCase(Left$(Result, 1))
            Else
                Mid$(Result, j, 1) = UCase(Left$(Result, 1))
            End If
            i = i + 1: j = j + 1
            Do Until j > jMax
                If i > iMax Then i = 2 ' если центральная часть приводимого закончилась - начинаем сначала
                s = Mid$(Template, i, 1)
                ' если тип символа приводимого шаблона совпадает с типом шаблона нового слова
                ' берем регистр символа приводимого шаблона и присваиваем символу нового
                If LCase(Mid$(NewTemp, j, 1)) = LCase(s) Then
                    i = i + 1
                    If LCase(s) = s Then
                        Mid$(Result, j, 1) = LCase$(Mid$(Result, j, 1))
                        Mid$(NewTemp, j, 1) = LCase$(Mid$(NewTemp, j, 1))
                    Else
                        Mid$(Result, j, 1) = UCase$(Mid$(Result, j, 1))
                        Mid$(NewTemp, j, 1) = UCase$(Mid$(NewTemp, j, 1))
                    End If
                End If
                j = j + 1
            Loop
            Template = NewTemp
        End If
        ' собственно форматируем слово
    Case Else ' оставляем как есть
    End Select
HandleExit:  p_SetSymbCase = Result: Exit Function
HandleError: Result = Word: Err.Clear: Resume HandleExit
End Function
Private Function p_IsExist(Key As String, Coll As Collection, Optional ByRef Value) As Boolean
' проверяет наличие элемента в коллекции
'-------------------------
    On Error GoTo HandleError
    Value = Coll(Key)
HandleExit:  p_IsExist = True:  Exit Function
HandleError: p_IsExist = False: Err.Clear
End Function
Private Function Pwr2(Index) As Long
' возвращает степени числа 2. нужна для битовых операций
'-------------------------
    On Error GoTo HandleError
    If Index < 0 Or Index > 31 Then Err.Raise vbObjectError
    Select Case Index
    Case 0:     Pwr2 = &H1&
    Case 1:     Pwr2 = &H2&
    Case 2:     Pwr2 = &H4&
    Case 3:     Pwr2 = &H8&
    Case 4:     Pwr2 = &H10&
    Case 5:     Pwr2 = &H20&
    Case 6:     Pwr2 = &H40&
    Case 7:     Pwr2 = &H80&
    Case 8:     Pwr2 = &H100&
    Case 9:     Pwr2 = &H200&
    Case 10:    Pwr2 = &H400&
    Case 11:    Pwr2 = &H800&
    Case 12:    Pwr2 = &H1000&
    Case 13:    Pwr2 = &H2000&
    Case 14:    Pwr2 = &H4000&
    Case 15:    Pwr2 = &H8000&
    Case 16:    Pwr2 = &H10000
    Case 17:    Pwr2 = &H20000
    Case 18:    Pwr2 = &H40000
    Case 19:    Pwr2 = &H80000
    Case 20:    Pwr2 = &H100000
    Case 21:    Pwr2 = &H200000
    Case 22:    Pwr2 = &H400000
    Case 23:    Pwr2 = &H800000
    Case 24:    Pwr2 = &H1000000
    Case 25:    Pwr2 = &H2000000
    Case 26:    Pwr2 = &H4000000
    Case 27:    Pwr2 = &H8000000
    Case 28:    Pwr2 = &H10000000
    Case 29:    Pwr2 = &H20000000
    Case 30:    Pwr2 = &H40000000
    Case 31:    Pwr2 = &H80000000
    Case Else:  Pwr2 = 0
    End Select
HandleExit:  Exit Function
HandleError: Err.Clear: Resume HandleExit
End Function

